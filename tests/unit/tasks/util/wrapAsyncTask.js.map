{"version":3,"file":"wrapAsyncTask.js","sourceRoot":"","sources":["../../../../../tests/unit/tasks/util/wrapAsyncTask.ts"],"names":[],"mappings":";;;;;;;;;;;IAAA,+BAA6B;IAC7B,2DAA8E;IAC9E,+CAAwD;IAEhD,IAAA,2DAAa,CAAmC;IAChD,IAAA,wCAAM,CAA8B;IAE5C,IAAM,QAAQ,GAAG,YAAI,EAAE,CAAC;IACxB,IAAM,QAAQ,GAAG,YAAI,EAAE,CAAC;IACxB,IAAM,UAAU,GAAG,EAAE,KAAK,EAAE,YAAI,EAAE,EAAE,CAAC;IAErC,IAAI,aAAkB,CAAC;IAEvB,aAAa,CAAC,0BAA0B,EAAE;QACzC,SAAS;YACR,QAAQ,CAAC,KAAK,EAAE,CAAC;YACjB,QAAQ,CAAC,KAAK,EAAE,CAAC;YACjB,UAAU,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;QAC1B,CAAC;QAED,MAAM;YACL,aAAa,GAAG,oBAAU,CAAC,OAAO,EAAE,sCAAsC,EAAE;gBAC3E,eAAe,EAAE,EAAE,MAAM,EAAE,UAAU,EAAE;aACvC,CAAC,CAAC;QACJ,CAAC;QAED,KAAK;YACJ,+BAAkB,EAAE,CAAC;QACtB,CAAC;QAED,KAAK,EAAE;YACP,iBAAiB,EAAE,CAAC;gBACnB,8BAAyC,OAAqB,EAAE,QAAoB,EAAE,OAAoB;oBACzG,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;oBAE1B,YAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;oBAEtC,aAAa,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBAEnC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;oBAOrB,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;gBAExC,CAAC;gBAED,MAAM,CAAC;oBACN,WAAW;wBACV,IAAM,WAAW,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;wBACtC,IAAM,cAAc,GAAG;4BACtB,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;4BAC1C,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC,CAAC;wBACtD,CAAC,CAAC;wBAEF,MAAM,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,cAAc,CAAC,CAAC;oBACrE,CAAC;oBAED,SAAS;wBACR,IAAM,WAAW,GAAG,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;wBAC9C,IAAM,aAAa,GAAG;4BACrB,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;4BAC1C,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC,CAAC;wBAClD,CAAC,CAAC;wBAEF,MAAM,CAAC,oBAAoB,CAAC,IAAI,CAC/B,IAAI,EAAE,WAAW,EAAE,qBAAc,CAAC,+BAA+B,CAAC,EAAE,aAAa,CACjF,CAAC;oBACH,CAAC;oBAED,6BAA6B;wBAC5B,IAAM,WAAW,GAAG,OAAO,CAAC,MAAM,CAAC,EAAE,OAAO,EAAE,eAAe,EAAE,CAAC,CAAC;wBACjE,IAAM,aAAa,GAAG;4BACrB,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC,CAAC;4BAC5D,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC,CAAC;wBAClD,CAAC,CAAC;wBAEF,MAAM,CAAC,oBAAoB,CAAC,IAAI,CAC/B,IAAI,EAAE,WAAW,EAAE,qBAAc,CAAC,+BAA+B,CAAC,EAAE,aAAa,CACjF,CAAC;oBACH,CAAC;iBACD,CAAC;YACH,CAAC,CAAC,EAAE;SACH;KACD,CAAC,CAAC","sourcesContent":["import { stub } from 'sinon';\nimport loadModule, { cleanupModuleMocks } from '../../../_support/loadModule';\nimport { throwWithError } from '../../../_support/util';\n\nconst { registerSuite } = intern.getInterface('object');\nconst { assert } = intern.getPlugin('chai');\n\nconst doneStub = stub();\nconst taskStub = stub();\nconst loggerStub = { error: stub() };\n\nlet wrapAsyncTask: any;\n\nregisterSuite('tasks/util/wrapAsyncTask', {\n\tafterEach() {\n\t\tdoneStub.reset();\n\t\ttaskStub.reset();\n\t\tloggerStub.error.reset();\n\t},\n\n\tbefore() {\n\t\twrapAsyncTask = loadModule(require, '../../../../tasks/util/wrapAsyncTask', {\n\t\t\t'../../src/log': { logger: loggerStub }\n\t\t});\n\t},\n\n\tafter() {\n\t\tcleanupModuleMocks();\n\t},\n\n\ttests: {\n\t'task eventually': (() => {\n\t\tfunction runWrapAsyncTaskTest(this: any, promise: Promise<any>, callback: () => void, errback?: () => void) {\n\t\t\ttaskStub.returns(promise);\n\n\t\t\tstub(this, 'async').returns(doneStub);\n\n\t\t\twrapAsyncTask(taskStub).call(this);\n\n\t\t\tthis.async.restore();\n\n\t\t\t// wrapAsyncTask performs the logic we're testing after the promise returned by the task it is\n\t\t\t// passed resolves or is rejected. So, in order to verify the results we need to test after the\n\t\t\t// promise is resolved(or rejected). By calling `then()` after wrapAsyncTask we can ensure\n\t\t\t// that the testing callbacks will be executed after the actual callbacks passed to `then` by\n\t\t\t// wrapAsyncTask.\n\t\t\treturn promise.then(callback, errback);\n\n\t\t}\n\n\t\treturn {\n\t\t\t'completes'(this: any) {\n\t\t\t\tconst taskPromise = Promise.resolve();\n\t\t\t\tconst callbackAssert = () => {\n\t\t\t\t\tassert.isTrue(loggerStub.error.notCalled);\n\t\t\t\t\tassert.isTrue(doneStub.calledWithExactly(undefined));\n\t\t\t\t};\n\n\t\t\t\treturn runWrapAsyncTaskTest.call(this, taskPromise, callbackAssert);\n\t\t\t},\n\n\t\t\t'rejects'(this: any) {\n\t\t\t\tconst taskPromise = Promise.reject(undefined);\n\t\t\t\tconst errbackAssert = () => {\n\t\t\t\t\tassert.isTrue(loggerStub.error.notCalled);\n\t\t\t\t\tassert.isTrue(doneStub.calledWithExactly(false));\n\t\t\t\t};\n\n\t\t\t\treturn runWrapAsyncTaskTest.call(\n\t\t\t\t\tthis, taskPromise, throwWithError('Should reject when task fails'), errbackAssert\n\t\t\t\t);\n\t\t\t},\n\n\t\t\t'reject; logs error messages'(this: any) {\n\t\t\t\tconst taskPromise = Promise.reject({ message: 'error message' });\n\t\t\t\tconst errbackAssert = () => {\n\t\t\t\t\tassert.isTrue(loggerStub.error.calledWith('error message'));\n\t\t\t\t\tassert.isTrue(doneStub.calledWithExactly(false));\n\t\t\t\t};\n\n\t\t\t\treturn runWrapAsyncTaskTest.call(\n\t\t\t\t\tthis, taskPromise, throwWithError('Should reject when task fails'), errbackAssert\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t})()\n\t}\n});\n"]}