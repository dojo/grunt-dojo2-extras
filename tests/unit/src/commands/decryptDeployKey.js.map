{"version":3,"file":"decryptDeployKey.js","sourceRoot":"","sources":["../../../../../tests/unit/src/commands/decryptDeployKey.ts"],"names":[],"mappings":"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","sourcesContent":["import loadModule, { cleanupModuleMocks } from '../../../_support/loadModule';\nimport { stub } from 'sinon';\nimport { throwWithError } from '../../../_support/util';\n\nconst { registerSuite } = intern.getInterface('object');\nconst { assert } = intern.getPlugin('chai');\n\nlet decryptDeployKey: any;\n\nconst decryptDataObj = {\n\ton: stub(),\n\tpipe: stub()\n};\nconst decryptDataStub = stub();\nconst encryptedKeyFileStub = stub();\nconst keyFileStub = stub();\nconst existsSyncStub = stub();\nconst createWriteStreamStub = stub();\nconst createReadStreamStub = stub();\n\nregisterSuite('commands/decryptDeployKey', {\n\tafter() {\n\t\tcleanupModuleMocks();\n\t},\n\n\tbeforeEach() {\n\t\tdecryptDataObj.on.returns(decryptDataObj);\n\t\tdecryptDataObj.pipe.returns(decryptDataObj);\n\n\t\tdecryptDeployKey = loadModule(require, '../../../../src/commands/decryptDeployKey', {\n\t\t\t'../util/crypto': {\n\t\t\t\tdecryptData: decryptDataStub.returns(decryptDataObj)\n\t\t\t},\n\t\t\t'../util/environment': {\n\t\t\t\tdecryptKeyName: 'decryptKeyName',\n\t\t\t\tdecryptIvName: 'decryptIvName',\n\t\t\t\tencryptedKeyFile: encryptedKeyFileStub.returns('encryptedKeyFile'),\n\t\t\t\tkeyFile: keyFileStub.returns('keyFile')\n\t\t\t},\n\t\t\t'fs': {\n\t\t\t\texistsSync: existsSyncStub,\n\t\t\t\tcreateWriteStream: createWriteStreamStub.returns('writeStream'),\n\t\t\t\tcreateReadStream: createReadStreamStub.returns('readStream')\n\t\t\t}\n\t\t});\n\t},\n\n\tafterEach() {\n\t\tdecryptDataStub.reset();\n\t\tencryptedKeyFileStub.reset();\n\t\tkeyFileStub.reset();\n\t\texistsSyncStub.reset();\n\t\tcreateWriteStreamStub.reset();\n\t\tcreateReadStreamStub.reset();\n\t\tdecryptDataObj.on.reset();\n\t\tdecryptDataObj.pipe.reset();\n\t},\n\n\ttests: {\n\t'decryptDeployKey': (() => {\n\t\tfunction ensureDecryptionResolves() {\n\t\t\texistsSyncStub.onCall(0).returns(true);\n\t\t\texistsSyncStub.onCall(1).returns(false);\n\t\t\tdecryptDataObj.on.withArgs('close').yields();\n\t\t}\n\n\t\tfunction assertDecryptDeployKey(encryptedFile?: any, key?: any, iv?: any, decryptedFile?: any) {\n\t\t\tprocess.env.decryptKeyName = 'decryptKeyName';\n\t\t\tprocess.env.decryptIvName = 'decryptIvName';\n\n\t\t\tconst promise = decryptDeployKey(encryptedFile, key, iv, decryptedFile);\n\n\t\t\tassert.instanceOf(promise, Promise);\n\n\t\t\treturn promise;\n\t\t}\n\n\t\treturn {\n\t\t\tasync 'arguments passed in explicitly'() {\n\t\t\t\tensureDecryptionResolves();\n\n\t\t\t\tconst deployKeyDecrypted = await assertDecryptDeployKey('encrypted.file', 'decrypt key', 'decrypt iv', 'decrypted.file');\n\n\t\t\t\t// default arguments are not used\n\t\t\t\tassert.isTrue(encryptedKeyFileStub.notCalled);\n\t\t\t\tassert.isTrue(keyFileStub.notCalled);\n\n\t\t\t\t// promise function is properly called\n\t\t\t\tassert.isTrue(createReadStreamStub.calledOnce);\n\t\t\t\tassert.isTrue(createWriteStreamStub.calledOnce);\n\n\t\t\t\t// decryptData is expected to be called with the appropriate arguments\n\t\t\t\tassert.isTrue(decryptDataStub.calledOnce);\n\t\t\t\tassert.isTrue(decryptDataStub.calledWith('readStream', 'decrypt key', 'decrypt iv'));\n\n\t\t\t\t// decryptData pipe properly closed\n\t\t\t\tassert.isTrue(deployKeyDecrypted);\n\t\t\t},\n\n\t\t\tasync 'arguments obtained from default'() {\n\t\t\t\tensureDecryptionResolves();\n\n\t\t\t\tconst deployKeyDecrypted = await assertDecryptDeployKey();\n\n\t\t\t\tassert.isTrue(deployKeyDecrypted);\n\t\t\t\tassert.isTrue(existsSyncStub.calledTwice);\n\t\t\t},\n\n\t\t\tasync 'nonexistent files and falsy arguments; eventually returns false'() {\n\t\t\t\texistsSyncStub.returns(false);\n\n\t\t\t\tassert.isFalse(await assertDecryptDeployKey());\n\t\t\t},\n\n\t\t\tasync 'decryption eventually rejects'() {\n\t\t\t\texistsSyncStub.onCall(0).returns(true);\n\t\t\t\texistsSyncStub.onCall(1).returns(false);\n\t\t\t\tdecryptDataObj.on.withArgs('error').yields(new Error('error'));\n\n\t\t\t\treturn assertDecryptDeployKey().then(\n\t\t\t\t\tthrowWithError('Should reject when necessary files don\\'t exist'),\n\t\t\t\t\t(err: Error) => {\n\t\t\t\t\t\tassert.strictEqual(err.message, 'error');\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t})()\n\t}\n});\n"]}